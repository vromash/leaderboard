// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
)

const createScore = `-- name: CreateScore :exec
INSERT INTO "score" ("score", "user_id")
VALUES ($1, $2)
`

type CreateScoreParams struct {
	Score  int64
	UserID int64
}

func (q *Queries) CreateScore(ctx context.Context, arg CreateScoreParams) error {
	_, err := q.db.ExecContext(ctx, createScore, arg.Score, arg.UserID)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO "user" ("name")
VALUES ($1)
`

func (q *Queries) CreateUser(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createUser, name)
	return err
}

const getAllScores = `-- name: GetAllScores :many
SELECT score.id, score, user_id, u.id, name
FROM "score"
         LEFT JOIN "user" u on u.id = score.user_id
ORDER BY "score"
`

type GetAllScoresRow struct {
	ID     int64
	Score  int64
	UserID int64
	ID_2   int64
	Name   string
}

func (q *Queries) GetAllScores(ctx context.Context) ([]GetAllScoresRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllScores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllScoresRow
	for rows.Next() {
		var i GetAllScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.Score,
			&i.UserID,
			&i.ID_2,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScore = `-- name: UpdateScore :exec
UPDATE "score"
SET "score" = $1
WHERE "user_id" = $2
`

type UpdateScoreParams struct {
	Score  int64
	UserID int64
}

func (q *Queries) UpdateScore(ctx context.Context, arg UpdateScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateScore, arg.Score, arg.UserID)
	return err
}
